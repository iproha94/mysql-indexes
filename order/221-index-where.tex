\subsection{Индексы для WHERE}

Для запроса на листинге \ref{sql:index-on-where} строим индекс $(dob, last\_name)$ и если не учитывать селективность, то порядок полей не важен.
\begin{lstlisting}[language=sql, label=sql:index-on-where, caption={запрос для index-on-where}]
SELECT * 
FROM poet
WHERE last_name = ”Пушкин” 
    AND dob = 1799
\end{lstlisting}

\paragraph{Index-where правила}

Рассмотрим работу индексов на примере индекса $(a, b, c)$, где $a, b$ - числа, $c$ - строка.

Примеры работы индекса $(a, b, c)$:
\begin{enumerate}
\item $a = 5 \; AND \; b = 10 \; AND \; c="Hello\;world"$
\item $a = 5$ (т.к. $a$ - левый префикс индекса)
\item $a > 5$ (т.к. $a$ - левый префикс индекса)  
\item $a = 5 \; AND \; b = 10$ (т.к. $a, b$ - левый префикс индекса)       
\item $a = 5 \; AND \; b = 10 \; AND \; c\:LIKE\:"Hello\;w\%"$ (т.к. $LIKE$ использует левый префикс столбца)
\item $a = 5 \; AND \; b \; IN \; (2,3)$ (т.к. $IN$ - рассматривается как поиск по диапазону)
\end{enumerate}

Примеры, когда индекс $(a, b, c)$ не работает:
\begin{enumerate}
\item $b = 5$ (т.к. $b$ - не левый префикс индекса)
\item $a=5 \; AND \; b=10 \; AND \; c\:LIKE\:"\% world"$ (т.к. $LIKE$ использует не левый префикс столбца)
\item $a=5 \; AND \; c=10$ (т.к. пропущен столбец $b$) \\
Но с помощью индекса $(a, b, c)$, MySQL сделает выборку по условию $a=5$, а дальше будут просмотрены все строки из этой выборки. Это будет частичным индексом.
\item $a>5 \; AND \; b=2$ (т.к. по столбцу $a$ используется условие поиска по диапазону, то индекс сработает только частично)
\end{enumerate}

