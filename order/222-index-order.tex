\subsection{Индексы при сортировке}

В индексе данные хранятся в отсортированном виде, поэтому дополнительно сортировать данные выборки не потребуется.

Для запроса на листинге \ref{sql:index-order1} строим индекс \textit{(dob)}.

\begin{lstlisting}[language=sql, label=sql:index-order1, caption={запрос для index-order}]
SELECT * 
FROM poet
ORDER BY dob
\end{lstlisting}

Для запроса на листинге \ref{sql:index-order2} строим индекс \textit{(country, dob)}. В индексе находим строки, удовлетворяющие условию \textit{country="ru"}, а в этой выборке строки уже отсортированы по \textit{dob}.

\begin{lstlisting}[language=sql, label=sql:index-order2, caption={запрос для index-order}]
SELECT * 
FROM poet
WHERE country="ru" 
ORDER BY dob
\end{lstlisting}

Для запроса на листинге \ref{sql:index-order3} строим индекс \textit{(dob)}. \textit{GROUP BY} возьмет уже отсортированные строки из индекса и уберет повторы, а т.к. строки уже отсортированные - \textit{ORDER BY} всего лишь задаст, в каком порядке выводить данные. 

\begin{lstlisting}[language=sql, label=sql:index-order3, caption={запрос для index-order}]
SELECT *
FROM poet
GROUP BY dob
ORDER BY dob
\end{lstlisting}


Рассмотрим работу индексов на примере индекса \textit{(a, b)}, где \textit{a, b} - числа.

\paragraph{Примеры запросов, к которым применяется индекс \textit{(a, b)}}

\begin{enumerate}
\item сортировка по первой колонке
\item первая колонка в условии \textit{WHERE}, и сортировка по второй колонке
\item первая колонка в условии \textit{WHERE} и сортировка по первой колонке
\item сортировка по двум колонкам и обе в одну сторону
\end{enumerate}

\paragraph{Примеры запросов, к которым не применяется индекс \textit{(a, b)}}

\begin{enumerate}
\item \textit{ORDER BY b}
\item \textit{WHERE a>5 ORDER BY b} \\
Пример данных в индексе \textit{(a, b): a=6, b=2; a=6, b=3; a=7, b=0; a=8, b=1}. MySQL сделает выборку по условию \textit{a>5}, но в этой выборке строки не отсортированы по \textit{b}.
\item \textit{WHERE a IN (1,2) ORDER BY b} (аналогично предыдущему запросу)
\item сортировка разных столбцов в разных направлениях (чтобы обойти это, можно сделать виртуальную колонку, например, перед числом поставить минус)
\end{enumerate}