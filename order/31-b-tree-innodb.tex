\section{B-tree индексы в MySQL InnoDB}
\label{section:b-tree-indexes-innodb}

В данной работе рассматриваются только B-tree-индексы для подсистемы хранения InnoDB.

Рассмотрим более подробно B-tree индексы в MySQL InnoDB. В качестве примера возьмем таблицу \ref{tabular:poets}, заголовок которой $poet (poet\_id, last\_name, first\_name, dob, country)$

\begin{table}[h]
\caption{Таблица поэтов}
\label{tabular:poets}
\medskip
\begin{tabular}{|l|l|l|l|l|}
\hline
poet\_id & last\_name & first\_name & dob & country\\
\hline
1 & "Блок" & "Александр" & 1880 & "ru"\\
2 & "Фет" & "Афанасий" & 1820 & "ru"\\
3 & "Лермонтов" & "Михаил" & 1814 & "ru"\\
4 & "Ильф" & "Илья" & 1897 & "ru"\\
5 & "Пушкин" & "Александр" & 1799 & "ru"\\
6 & "Булгаков" & "Михаил" & 1891 & "ru"\\
7 & "Есенин" & "Сергей" & 1895 & "ru"\\
\hline
\end{tabular}
\end{table}

\subsection{Кластерный индекс}

В InnoDB данные хранятся в структуре данных B+tree, где в узловых страницах хранятся первичные ключи, а в листовых страницах хранятся данные. Такое дерево называется кластерным индексом. Над таблицей можно построить только один кластерный индекс, поскольку невозможно хранить одну и ту же запись одновременно в двух местах. Однако часть или всю запись можно хранить в нескольких местах, что будет использоваться в покрывающих индексах \ref{section:covering-index}.

Для рисунка \ref{img:btree-structure} и таблицы \ref{tabular:poets}: $k_1 \ldots k_7$ - первичные ключи ($poet\_id$), $k_i = i$, $d_1 \ldots d_7$ - данные, т.е. $d_1$ = Блок, Александр, 1880, ru; $d_2$ = Фет, Афанасий, 1820, ru; $\ldots$


\subsection{Вторичный индекс}

Для оптимизации конкретных запросов используются \textit{вторичные индексы} (далее просто индексы). В узловых страницах индексов хранятся поля, по которым создан этот индекс, а в листовых страницах хранится значение первичного ключа. Для каждой таблицы в одном запросе используется только один индекс. При использовании в запросах индекса, сначала будет найдено значение первичного ключа, затем по этому значению будут найдены данные в кластерном индексе. Поэтому при создании вторичного индекса, в конец неявно добавляется первичный ключ.

На рисунке \ref{img:index-structure} показан индекс по полю \textit{(dob)}: $k_1 \ldots k_7$ - ключи, по которым построен индекс; $k_1$ = 1799, $k_2$ = 1814, $k_3$ = 1820, $\ldots$; $p_1 \ldots p_7$ - первичные ключи ($poet\_id$); $p_i = i$.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.6]{index-structure.png}
  \caption{Структура вторичного индекса}
  \label{img:index-structure}
\end{figure}


\subsection{Составной индекс}

\textit{Составной индекс} - это индекс, построенный по нескольким полям. Чтобы правильно использовать составные индексы, необходимо понять структуру их хранения. Все работает точно так же, как и для обычного индекса, но для значений используются значения всех входящих колонок сразу, по которым строится индекс.

Если построить индекс по полям \textit{(dob, last_name)}, то для рисунка \ref{img:index-structure} $k_1$ = 1799Пушкин, $k_2$ = 1814Лермонтов, $k_3$ = 1820Фет, $\ldots$

\subsection{Частичный индекс}

\textit{Составной индекс} может использоваться не полностью, но только как левый префикс. Такое использование индекса наызвается \textit{частичным индексом}. 

Оператор \textit{LIKE} с использованием знака \% в конце указываемого шаблона рассматривается как левый префикс.

\subsection{Селективность индексов}

Чем меньше строк войдет в выборку, тем быстрее будет работать поиск по ней. Индекс, дающий наименьшую выборку, называется \textit{более селективным}. Если СУБД может применить несколько индексов к данному SQL запросу, то использоваться будет более селективный.

\subsection{Покрывающий индекс}
\label{section:covering-index}

Индекс называется \textit{покрывающим}, если в нем есть все поля, используемые в запросе. Для того чтобы вернуть результат запроса при использовании покрывающего индекса СУБД не нужно обращаться к кластерному индексу. Покрывающие индексы позволяют имитировать кластерные индексы. 

Для запроса на листинге \ref{sql:covering-index} можно построить индекс $(last\_name, dob)$, который будет считаться покрывающим.
\begin{lstlisting}[language=sql, label=sql:covering-index, caption={запрос для covering-index}]
SELECT last_name, dob
FROM poet
WHERE last_name = "Пушкин"
\end{lstlisting}
