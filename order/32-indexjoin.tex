\section{Indexjoin алгоритм}

\textbf{Indexjoin алгоритм} - алгоритм, для определения индексов, которые могут быть использованы СУБД для оптимизации выполнения SQL запроса. Алгоритм на вход принимает \textit{join запрос} и возвращает множество пар индексов. В каждой паре первый индекс - индекс для первой таблицы, второй индекс - индекс для второй таблицы. Если в индексе нет полей, значит по таблице не нужно строить индекс. 

Введем некоторые обозначения:
\begin{enumerate}
\item \textit{index(T)} - индекс-множество для таблицы T, под которым подразумевается конечное множество индексов. Знак восклицания (!) означает фиксированное поле в индексе. Нефиксированные поля можно менять местами только между фиксированными полями, началом и концом. Например \textit{T(a, b, c!, d, e) $\equiv$ t(a, b, c, d, e), t(b, a, c, d, e), t(a, b, c, e, d), t(b, a, c, e, d)};

\item \textit{[joinFields]} $\gets$ \textit{getJoinFields(query)} - получить поля, по которым происходит соединение таблиц по SQL запросу \textit{query};

\item \textit{index(T)} $\gets$ \textit{deleteFieldsFromIndex(index(T), [fields])} - из \textit{index(T)}  удалить поля, перечисленные в массиве \textit{[fields]};

\item  \textit{[(x, y)]} $\gets$ \textit{cartesianProduct(X, Y)} - Из пар индекс-множеств \textit{(X, Y)} через прямое произведение множеств \textit{X, Y} получить всевозможные пары индексов \textit{(x, y)};

\item \textit{index(T)} $\gets$ \textit{createIndexSet(query)} - построить индекс-множество по SQL запросу \textit{query}.
\end{enumerate}

В качестве \textit{indexjoin алгоритма} для \textit{join запроса} можно предложить алгоритм, при работе которого происходит анализ исследуемого запроса. Псевдокод представлена в алгоритме \ref{alg:indexjoin}. Блок-схема представлена на рисунке \ref{img:indexjoin}.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{indexjoin.png}
  \caption{Блок-схема indexjoin алгоритма.}
  \label{img:indexjoin}
\end{figure}

\begin{algorithm}[h!]
\caption{Indexjoin алгоритм}
\label{alg:indexjoin}

\begin{algorithmic}[1]
\Function{indexjoinAlg}{query}

    \State T $\gets$ \Call{fullscanAlg}{query}
    \Statex 
    
    \Comment{---begin block1---}
    \If {T $\neq$ NULL}
        \State {query1 $\gets$ query (отбросив в блоке сортировки поля, идущие после начальных полей таблицы T)}
    \Else
        \State {query1 $\gets$ query}
    \EndIf
    \Comment{---end block1---}
    \Statex 

    \Comment{---begin block2---}
    \State query21 $\gets$ query1 (без полей таблицы t2, при этом в условии соединения поля таблицы t2 заменить на CONST)
    \Statex

    \State query22 $\gets$ query1 (без полей таблицы t1, при этом в условии соединения поля таблицы t1 заменить на CONST
    \Comment{---end block2---}
    \Statex

    \State index(t1) $\gets$ createIndexSet(query21)
    \State index(t2) $\gets$ createIndexSet(query22)
    \State {joinFields $\gets$ getJoinFields(query)}
    \Statex

    
    \If {T $\neq$ NULL}
    \Statex\Comment{---begin block3---}
        \State {index(T) $\gets$ deleteFieldsFromIndex(index(T), joinFields)}

        \Statex
        \State result $\gets$ cartesianProduct(index(t1), index(t2))
    \Statex\Comment{---end block3---}
    \Else
    \Statex\Comment{---begin block4---}
        \State {index1(t1) $\gets$ index(t1)}
        \State {index2(t2) $\gets$ deleteFieldsFromIndex(index(t2), joinFields)}
        
        \Statex
        \State {index1(t2) $\gets$ index(t2)}
        \State {index2(t1) $\gets$ deleteFieldsFromIndex(index(t1), joinFields)}

        \Statex
        \State result $\gets$ cartesianProduct(index1(t1), index2(t2)), cartesianProduct(index1(t2), index2(t1))
    \Statex\Comment{---end block4---}
    \EndIf

    \Statex
    \State \Return result
\EndFunction
\end{algorithmic}

\end{algorithm}


\paragraph{Примеры для участков кода \textit{block1}}

Пусть \textit{T = t2, query = $\ldots$ ORDER BY t2.z, t2.y, t1.z, t1.y, t2.x $\ldots$}

тогда \textit{query1 = $\ldots$ ORDER BY t2.z, t2.y}

Пусть \textit{T = t2, query = $\ldots$ ORDER BY t1.x, t2.x $\ldots$}

тогда отбрасываются все поля (т.е. в \textit{query1} не будет сортировки)

\paragraph{Примеры для участков кода \textit{block2}}

Пусть \textit{query1 = $\ldots$ ON t1.a = t2.a WHERE t1.b = Z, t2.b = Y $\ldots$}

тогда \textit{query21 = $\ldots$ ON t1.a = const1 WHERE t1.b = Z $\ldots$}

\paragraph{Примеры для участков кода \textit{block3}}

Пусть \textit{T = t1, index(t1) = t1(a, b), index(t2) = t2(c, a), query0 = $\ldots$ ON t1.a = t2.a $\ldots$}

тогда \textit{index(t1) = t1(b), index(t2) = t2(c, a)}

\paragraph{Примеры для участков кода \textit{block4}}

Пусть \textit{index(t1) = t1(a, b, c), index(t2) = t2(a, b, c), query1 = $\ldots$ ON t1.a = t2.a $\ldots$} 

тогда \textit{index1(t1) = t1(a, b, c), index2(t2) = t2(b, c), index2(t1) = t1(b, c), index1(t2) = t2(a, b, c)}

\subsection{Примеры работы алгоритма}

Рассмотрим работу indexjoin алгоритма по обработке заданного SQL запроса на конкретных практических примерах.

\paragraph{Пример №1}

\begin{lstlisting}[language=SQL]
query := t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.b > 1 AND t2.c = 5

T := NULL 

query1 := query 

query21 := ON t1.a = const WHERE t1.b > 1 
query22 := ON t2.a = const WHERE t2.c = 5

index(t1) := t1(a, b!) 
index(t2) := t2(a, c) 

index1(t1) := t1(a, b!) 
index2(t2) := t2(c) 

index1(t2) := t2(a, c) 
index2(t1) := t1(b) 
\end{lstlisting}

(t1(a, b!), t2(c)) $\equiv$ (t1(a, b), t2(c)) 

(t1(b), t2(a, c)) $\equiv$ (t1(b), t2(a, c)), (t1(b), t2(c, a)) 

\textbf{Ответ:} \textit{(t1(a, b), t2(c)), (t1(b), t2(a, c)), (t1(b), t2(c, a))} - множество пар индексов, наиболее подходящих данному запросу. 


\paragraph{Пример №2}
\begin{lstlisting}[language=SQL]
query := FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.b = 5000 AND t1.c > 3 ORDER BY t2.c, t2.d

T := t1 

query1 := FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.b = 5000 AND t1.c > 3

query21 := ON t1.a = const WHERE t1.b = 5000 AND t1.c > 3 
query22 := ON t2.a = const

index(t1) := t1(a, b, c!) 
index(t2) := t2(a) 

index(t1) := t1(b, c!) 
\end{lstlisting}
 
(t1(b, c!), t2(a)) $\equiv$ {(t1(b, c), t2(a))} 

\textbf{Ответ:} \textit{(t1(b, c), t2(a))} - множество пар индексов, наиболее подходящих данному запросу.


\paragraph{Пример №3}
\begin{lstlisting}[language=SQL]
query := FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t2.b = 5000 AND t2.c > 3 ORDER BY t2.c, t2.d

T := t2

query1 := query 

query21 := ON t1.a = const 
query22 := ON t2.a = const WHERE t2.b = 5000 AND t2.c > 3 ORDER BY t2.c, t2.d 

index(t1) := t1(a) 
index(t2) := t2(a, b, c!, d!) 

index(t2) := t2(b, c!, d!) 
\end{lstlisting}

(t1(a), t2(b, c!, d!)) $\equiv$ (t1(a), t2(b, c, d)) 

\textbf{Ответ:} \textit{(t1(a), t2(b, c, d))} - множество пар индексов, наиболее подходящих данному запросу.


\paragraph{Пример №4}
\begin{lstlisting}[language=SQL]
query := FROM t1 LEFT JOIN t2 ON t2.a = t1.a ORDER BY t2.b

T := t1 

query1 := t1 LEFT JOIN t2 ON t2.a = t1.a 

query21 := ON t1.a = const 
query22 := ON t2.a = const 

index(t1) := t1(a) 
index(t2) := t2(a) 

index(t1) := t1() 
\end{lstlisting}
 
(t1(), t2(a)) $\equiv$ (t1(), t2(a)) 

\textbf{Ответ:} \textit{(t1(), t2(a))} - множество пар индексов, наиболее подходящих данному запросу.


\paragraph{Пример №5}
\begin{lstlisting}[language=SQL]
query := 
    t1 INNER JOIN t2
        ON t1.a = t2.a
    WHERE t1.b = const
    ORDER BY t1.c
\end{lstlisting}

\textbf{Ответ:} \textit{(t1(b, c), t2(a))} - множество пар индексов, наиболее подходящих данному запросу.


% \paragraph{Пример №6}
% \begin{lstlisting}[language=SQL]
% query = {
%     t1 LEFT JOIN t2
%         ON t2.id = t1.id_n
%             AND t2.c = 5
%     WHERE t1.b > 1
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.

% \paragraph{Пример №7}
% \begin{lstlisting}[language=SQL]
% query = {
%     t1 LEFT JOIN t2
%         ON t2.a = t1.a
%     ORDER BY t1.b
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.

% \paragraph{Пример №7}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT *
%     FROM t1 LEFT JOIN t2
%         ON t1.a = t2.a
%     WHERE t1.b = 5000
%     ORDER BY t2.a
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.

% \paragraph{Пример №8}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT *
%     FROM t1 LEFT JOIN t2
%         ON t1.b = t2.b
%     WHERE t1.c = 5000
%         AND t2.c = 5000
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.

% \paragraph{Пример №9}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT *
%     FROM t1 INNER JOIN t2
%         ON t1.b = t2.b
%             AND t2.c = 5000
%     WHERE t1.c > 0
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.


% \paragraph{Пример №10}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT t2.b
%     FROM t1 LEFT JOIN t2
%         ON t1.c = t2.c
%             AND t2.d = 5000
%     ORDER BY t2.b
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.


% \paragraph{Пример №11}
% \begin{lstlisting}[language=SQL]
% query = {
%     FROM t1 LEFT JOIN t2
%         ON t1.b = t2.b
%     WHERE t1.c = 5000
%         AND t2.c = 5000
%     ORDER BY t2.b
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.


% \paragraph{Пример №12}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT *
%     FROM t1 LEFT JOIN t2
%         ON t1.b = t2.b
%     WHERE t2.d like 'ABC%'
%     ORDER BY t2.d
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.


% \paragraph{Пример №13}
% \begin{lstlisting}[language=SQL]
% query = {
%     SELECT *
%     FROM t1 LEFT JOIN t2
%         ON t1.b = t2.b
%             AND t2.a like 'A%'
%     ORDER BY t2.d
% }
% \end{lstlisting}

% \textbf{Ответ:} ${}$ - множество пар индексов, наиболее подходящих данному запросу.